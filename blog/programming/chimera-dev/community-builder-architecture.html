<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Community Builder Architecture | Chimera Forums</title>
    <link rel="stylesheet" href="../../../styles.css">
</head>
<body>
    <nav class="nav">
        <div class="nav-container">
            <a href="../../../index.html" class="nav-logo">
                <span class="logo-text">Terrell K. Flautt</span>
            </a>
            <div class="nav-links">
                <a href="../../../index.html">Home</a>
                <a href="../index.html">Dev Blog</a>
            </div>
        </div>
    </nav>

    <article style="max-width: 800px; margin: 0 auto; padding: 2rem;">
        <header>
            <h1>Serverless Community Builder</h1>
            <p><time>Oct 16, 2025</time> · 8 min · Privacy-focused social platform</p>
        </header>

        <h2>Design Philosophy</h2>
        <p><strong>Cleaner than Discord. Simpler than Reddit. More private than everything.</strong></p>

        <p>Users should be able to create their own communities without sacrificing privacy or dealing with complex admin panels.</p>

        <h2>Core Architecture</h2>

        <h3>Multi-Tenant Community System</h3>
        <pre><code>// Single infrastructure, infinite communities
const COMMUNITY_TABLE = 'Communities';
const CHANNELS_TABLE = 'Channels';

exports.createCommunity = async (event) => {
    const { name, description, isPrivate, encryption } = JSON.parse(event.body);
    const creatorId = event.requestContext.authorizer.userId;

    const community = {
        id: generateSlug(name),  // forum.site.com/c/my-community
        name,
        description,
        creatorId,
        isPrivate,
        encryption: encryption || 'none',  // 'none', 'e2e', 'server'
        members: [creatorId],
        roles: {
            [creatorId]: 'owner'
        },
        createdAt: Date.now()
    };

    // Generate encryption keys if E2E
    if (encryption === 'e2e') {
        const communityKeys = await generateCommunityKeys();
        community.publicKey = communityKeys.publicKey;
        // Private key shared only with members via encrypted channel
    }

    await dynamodb.put({
        TableName: COMMUNITY_TABLE,
        Item: community
    }).promise();

    // Create default channels
    await createDefaultChannels(community.id);

    return {
        statusCode: 201,
        body: JSON.stringify({ community })
    };
};</code></pre>

        <h3>Channel System</h3>
        <pre><code>// Discord-style channels with privacy controls
async function createChannel(communityId, channelData) {
    const { name, type, permissions } = channelData;

    const channel = {
        id: uuidv4(),
        communityId,
        name,
        type,  // 'text', 'voice', 'poll', 'files'
        permissions: permissions || 'all-members',
        encrypted: type === 'text',  // All text encrypted by default
        ephemeral: channelData.ephemeral || false,
        createdAt: Date.now()
    };

    await dynamodb.put({
        TableName: CHANNELS_TABLE,
        Item: channel
    }).promise();

    return channel;
}

// Default channel structure
async function createDefaultChannels(communityId) {
    const defaults = [
        { name: 'general', type: 'text', permissions: 'all-members' },
        { name: 'announcements', type: 'text', permissions: 'read-only' },
        { name: 'off-topic', type: 'text', permissions: 'all-members' }
    ];

    for (const channel of defaults) {
        await createChannel(communityId, channel);
    }
}</code></pre>

        <h2>User Experience</h2>

        <h3>Simple Community Creation Flow</h3>
        <pre><code>// React component - 3 steps to create community
function CreateCommunityWizard() {
    const [step, setStep] = useState(1);
    const [community, setCommunity] = useState({
        name: '',
        description: '',
        isPrivate: false,
        encryption: 'e2e'
    });

    const steps = [
        { title: 'Name & Description', component: BasicInfo },
        { title: 'Privacy Settings', component: PrivacySettings },
        { title: 'Create', component: Confirmation }
    ];

    async function handleCreate() {
        const response = await fetch('/api/communities', {
            method: 'POST',
            body: JSON.stringify(community)
        });

        const { community: created } = await response.json();
        window.location.href = `/c/${created.id}`;
    }

    return (
        <div className="wizard">
            <h2>{steps[step - 1].title}</h2>
            {React.createElement(steps[step - 1].component, {
                data: community,
                onChange: setCommunity
            })}
            {step === 3 && <button onClick={handleCreate}>Create Community</button>}
        </div>
    );
}</code></pre>

        <h3>Role-Based Access Control</h3>
        <pre><code>// Simple but powerful permissions
const ROLES = {
    owner: {
        canModerate: true,
        canInvite: true,
        canEditChannels: true,
        canEditCommunity: true,
        canDeleteCommunity: true
    },
    moderator: {
        canModerate: true,
        canInvite: true,
        canEditChannels: true,
        canEditCommunity: false,
        canDeleteCommunity: false
    },
    member: {
        canModerate: false,
        canInvite: false,
        canEditChannels: false,
        canEditCommunity: false,
        canDeleteCommunity: false
    }
};

function canPerformAction(userId, communityId, action) {
    const userRole = getCommunityRole(userId, communityId);
    return ROLES[userRole][action] === true;
}</code></pre>

        <h2>Privacy Features</h2>

        <h3>1. Private Communities</h3>
        <pre><code>// Invite-only with encrypted invites
exports.createInvite = async (event) => {
    const { communityId, inviteeEmail } = JSON.parse(event.body);
    const inviterId = event.requestContext.authorizer.userId;

    // Generate one-time invite token
    const inviteToken = crypto.randomBytes(32).toString('hex');

    const invite = {
        token: inviteToken,
        communityId,
        inviterId,
        inviteeEmail,
        expiresAt: Date.now() + (7 * 24 * 60 * 60 * 1000),  // 7 days
        used: false
    };

    await dynamodb.put({
        TableName: 'Invites',
        Item: invite
    }).promise();

    // Send encrypted invite link
    const inviteLink = `https://forum.site.com/invite/${inviteToken}`;
    await sendEncryptedEmail(inviteeEmail, inviteLink);

    return { statusCode: 200 };
};</code></pre>

        <h3>2. Content Moderation Without Surveillance</h3>
        <pre><code>// Community-driven moderation with zero knowledge
exports.reportContent = async (event) => {
    const { messageId, reason } = JSON.parse(event.body);

    // Create encrypted report that only moderators can decrypt
    const moderatorKeys = await getCommunityModeratorKeys(communityId);

    const encryptedReport = await encryptForModerators({
        messageId,
        reason,
        encryptedContent: message.encryptedContent,  // Pass through encrypted
        reportedAt: Date.now()
    }, moderatorKeys);

    await dynamodb.put({
        TableName: 'Reports',
        Item: {
            id: uuidv4(),
            communityId,
            encryptedReport,
            status: 'pending'
        }
    }).promise();

    // Notify moderators via WebSocket
    await notifyModerators(communityId, 'new_report');
};</code></pre>

        <h3>3. Anonymous Participation Option</h3>
        <pre><code>// Users can choose anonymity per-community
function joinCommunityAnonymously(communityId) {
    const anonIdentity = {
        displayName: generateAnonymousName(),
        communityId,
        publicKey: null,  // Generate if they want encryption
        persistent: false  // Resets on session end
    };

    sessionStorage.setItem(
        `anon_${communityId}`,
        JSON.stringify(anonIdentity)
    );

    return anonIdentity;
}</code></pre>

        <h2>Real-Time Features</h2>

        <h3>WebSocket Message Broadcasting</h3>
        <pre><code>// Scalable real-time messaging
exports.broadcastMessage = async (event) => {
    const { connectionId } = event.requestContext;
    const { channelId, encryptedContent } = JSON.parse(event.body);

    // Get all channel subscribers
    const subscribers = await getChannelSubscribers(channelId);

    // Broadcast to all connections except sender
    const apiGateway = new AWS.ApiGatewayManagementApi({
        endpoint: process.env.WEBSOCKET_ENDPOINT
    });

    const message = {
        type: 'message',
        channelId,
        encryptedContent,
        timestamp: Date.now()
    };

    await Promise.all(
        subscribers
            .filter(sub => sub.connectionId !== connectionId)
            .map(sub =>
                apiGateway.postToConnection({
                    ConnectionId: sub.connectionId,
                    Data: JSON.stringify(message)
                }).promise()
            )
    );
};</code></pre>

        <h2>Scaling Strategy</h2>

        <h3>Free Tier Design</h3>
        <ul>
            <li>Up to 1,500 users per community</li>
            <li>Unlimited communities</li>
            <li>30-day message retention</li>
            <li>Basic encryption (server-side)</li>
        </ul>

        <h3>DynamoDB Optimization</h3>
        <pre><code>// Efficient queries with GSI
const MESSAGES_GSI = 'ChannelTimestampIndex';

async function getChannelMessages(channelId, limit = 50) {
    const result = await dynamodb.query({
        TableName: 'Messages',
        IndexName: MESSAGES_GSI,
        KeyConditionExpression: 'channelId = :channelId',
        ExpressionAttributeValues: {
            ':channelId': channelId
        },
        ScanIndexForward: false,  // Latest first
        Limit: limit
    }).promise();

    return result.Items;
}</code></pre>

        <h2>Mobile App</h2>

        <h3>React Native + Expo</h3>
        <pre><code>// Push notifications for mentions
import * as Notifications from 'expo-notifications';

async function subscribeToPushNotifications(userId, communityId) {
    const token = await Notifications.getExpoPushTokenAsync();

    await fetch('/api/notifications/subscribe', {
        method: 'POST',
        body: JSON.stringify({
            userId,
            communityId,
            pushToken: token.data,
            platform: Platform.OS
        })
    });
}

// Handle encrypted notifications
Notifications.addNotificationReceivedListener(async (notification) => {
    const { encryptedContent } = notification.request.content.data;

    // Decrypt using stored private key
    const privateKey = await SecureStore.getItemAsync('pgp_private_key');
    const decrypted = await decryptMessage(encryptedContent, privateKey);

    // Show decrypted notification
    await Notifications.presentNotificationAsync({
        title: 'New Message',
        body: decrypted
    });
});</code></pre>

        <h2>What's Next</h2>
        <ul>
            <li>Voice channels with WebRTC</li>
            <li>File sharing with E2E encryption</li>
            <li>Custom bots and integrations</li>
            <li>Blockchain-based governance</li>
        </ul>

        <p><a href="https://forum.snapitsoftware.com">Join Chimera →</a></p>
    </article>
</body>
</html>
